---
title: XXXXXXXXX
author: XXXXXXX
date: MM/DD/YYYY
output: html_document
version: EA code version 4, C & N corrections with a blank correction only for N, Katie Snell
---
## NOTES about data reduction and run:
Fill in with notes about the run: e.g. settings for culling, and extra standards culled, which column of corrected data is used in the discrimination correction.

## Load libraries, data, and define standards
load necessary R libraries and data, define accepted standard values for correcting standards
```{r load-stuff}
library(tidyverse)
library(stringr)
library(openxlsx)
library(plotly)
```

load data and add inverse area columns
```{r load-data}
base.directory<-"~/Google Drive/Delta methods"  #change this file path if you move the clump.functions.R file
               #alternative for PC users: "C:\\Users\\V\\Google Drive\\Delta methods"

#stopifnot(file.exists(folder)) #presents an error if the folder containing the custom funcitons file isn't there or the path is wrong

source(file.path(base.directory, "custom.functions.R"))

session<-"XXXX"

raw.data<-read.csv("XXXXX.csv")

data<-raw.data
data$inv.area44<-1/data$area44
data$inv.area28<-1/data$area28

```

define standards used in run for correcting, monitoring and discrimination
```{r define-stnds}
corr.std<-"LSD"    #you should type the name of whichever standard you used for both your lin.std and drift.std here
C.acc <- -26.66
C.per.acc <- 1.56
N.acc <- -26.66+25
N.per.acc <- 1.56

dis.std<-"Pugel"
C.acc.dis <- -12.6
C.per.dis <- 44.02
N.acc.dis <- -12.6+25
N.per.dis <- 44.02

mon.std<-"Acetanilide1"
C.acc.mon <- -29.53
C.per.mon <- 71.09
N.acc.mon <- -29.53+25
N.per.mon <- 71.09

# data frame overview
C.stds.table <- 
  tribble( # data frame defined by row, instead of by column
    ~std.name, ~C.acc, ~C.per.acc, # define the column names
    corr.std, C.acc, C.per.acc,   # add row one
    mon.std, C.acc.mon, C.per.mon, # add row two
    dis.std, C.acc.dis, C.per.dis  # add row three, etc.
  )

N.stds.table <- 
  tribble( # data frame defined by row, instead of by column
    ~std.name, ~N.acc, ~N.per.acc, # define the column names
    corr.std, N.acc, N.per.acc,   # add row one
    mon.std, N.acc.mon, N.per.mon, # add row two
    dis.std, N.acc.dis, N.per.dis  # add row three, etc.
  )

```

## Initial dataset check plots and culling
Plot yields of everything, and then just the standards, using INTERACTIVE plots. Use this to cull more samples if need be, by looking for  statistical outliers that coincide with yield problems.
Note that the linear model in the yield.stds figure here is based on just the linearity data; other standars with different weight % C or N will not fall on the line, but should follow a similar trend if there is enough spead in the masses

Check to see that samples all fall within linearity range, and for any other obvious outliers
to check:

* do linearity standards cover the area space of your samples and other standards?
* do all the standards show typical trends between area and mass? Do you see very general trends like that in your samples?
* are blanks actually blank? 
    * If not, but still small, may need to do a blank correction for carbon (is already a part of the nitrogen corrections) - if carbon is diluted, likely won't need to do a blank correction
    * If not, and the areas are big, check your raw data and original peaks to be sure there isn't something wrong with your input data files (e.g. offset lines, etc) or that the analyses were off during the run (e.g. offset accidently in carousel, so names go with incorrect sample data)

```{r cull.outliers, fig.width=10, fig.height=6}
# adjust line 92: change #'s in stds.to.cull to reflect the row #'s that need to be culled, add row#'s as needed and rerun after looking at the new plots
stds.all<-subset(data, type!="empty" & type!="sample" & type!="blank")

stds.to.cull <- c(NA) #enter row #'s to cull here, separate by commas - stds with yield problems and/or significant outlier in d13C or d18O, can rerun this after 1st round to see outiers, than add them here

stds.culled <- filter(stds.all, row %in% stds.to.cull)
stds <- filter(stds.all, !row %in% stds.to.cull) 

stds<- data.frame(stds, cbind(predict.lm(lm(stds$area28 ~ stds$mass), interval=c("confidence"), level=0.95)))

yield.all<-ggplot(gather(data, area, area.value, area28, area44), aes(x=mass, y=area.value, fill=type, label=row)) +
  geom_point(size=3, shape=22) +
  theme_bw() +
  labs(title= "Yield plots") +
  facet_grid(.~area)

yield.stds<-ggplot(subset(gather(stds, area, area.value, area44, area28), type=="lin.std"), aes(x=mass, y=area.value, label=row)) +
  stat_smooth(method="lm") +   
  geom_point(data=gather(stds, area, area.value, area44, area28), aes(fill=type, shape=type), size=2) +
  theme_bw() +
  scale_shape_manual(values=c(21,22,23,24,25,21,22,23)) +
  labs(title= "Yield - standards only") +
  facet_grid(.~area, scales = "free")

calc_std_means_d13C <- function(df) calc_means(df, "d13C")

d13C.stds <- 
  ggplot(stds, aes(label=row)) +
  geom_hline(
    data = calc_std_means_d13C,
    mapping = aes(yintercept = yintercept, color = type, linetype = linetype)) +
  geom_point(shape=21, mapping = aes(x=area44, y=d13C, fill=type)) +
  scale_linetype_manual(values = c(1, 3, 2, 3, 2)) + 
  facet_grid(type ~ ., scales = "free") +
  theme_bw() +
  theme(legend.position="none") +
  labs(title= "d13C standards - means and uncertainties")

calc_std_means_d15N <- function(df) calc_means(df, "d15N")

d15N.stds <- 
  ggplot(stds, aes(label=row)) +
  geom_hline(
    data = calc_std_means_d15N,
    mapping = aes(yintercept = yintercept, color = type, linetype = linetype)) +
  geom_point(shape=21, mapping = aes(x=area28, y=d15N, fill=type)) +
  scale_linetype_manual(values = c(1, 3, 2, 3, 2)) + 
  facet_grid(type ~ ., scales = "free") +
  theme_bw() +
  theme(legend.position="none") +
  labs(title= "d15N standards - means and uncertainties")

ggplotly(yield.all)
ggplotly(yield.stds)
ggplotly(d13C.stds)
ggplotly(d15N.stds)
```

## Carbon corrections
Apply basic offset correction to all of the data; does NOT include linearity or drift correction to data - culling any additional standards that should be culled (e.g. 2 sd outliers)
```{r offset.C, fig.width=10, fig.height=5}

offsetC<-subset(stds, Identifier1==corr.std)

(offsetC.mean<-mean(offsetC$d13C))
(offsetC.sd<-sd(offsetC$d13C))

offsetC$d13C.offset <- offsetC$d13C +  (C.acc - offsetC.mean)

(offsetcorrC.mean<-mean(offsetC$d13C.offset))
(offsetcorrC.sd<-sd(offsetC$d13C.offset))

d13C.offset<-ggplot(offsetC, aes(x=area44, y=d13C.offset, shape=type)) +
  geom_point(fill="orange", size=3) +
  geom_hline(yintercept=offsetcorrC.mean, colour="orange") +
  geom_hline(yintercept=offsetcorrC.mean + offsetcorrC.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetcorrC.mean - offsetcorrC.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetcorrC.mean + 2*offsetcorrC.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=offsetcorrC.mean - 2*offsetcorrC.sd, colour="orange", linetype=3) +
  scale_shape_manual(values=c(21,22,23,24,25)) +
  annotate("text", y = offsetcorrC.mean + 0.01, x = min(offsetC$area44), 
    label = paste0("mean: ", sprintf("%.2f", offsetcorrC.mean), " \U00B1 ", sprintf("%.2f", offsetcorrC.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="black") +
  theme_bw() 

d13C.offset.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=offsetC, aes(x=mass, y=area44), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(d13C.offset, d13C.offset.mass, cols=2)
```

After finalizing the offset correction, apply it to the whole dataset, and check the monitoring standards
```{r apply.offset.corr.C, fig.width=10, fig.height=5}

#apply offset correction to whole dataset
data$d13C.offset <- data$d13C +  (C.acc - offsetC.mean)
stds$d13C.offset <- stds$d13C +  (C.acc - offsetC.mean)

#make monitoring standard dataset and dataset for additional standards used later for discrimination correction
offsetC.mon <- subset(stds, Identifier1==mon.std)
offsetC.dis <- subset(stds, Identifier1==dis.std)

#check monitoring standard response
(offsetC.mon.mean<-mean(offsetC.mon$d13C.offset))
(offsetC.mon.sd<-sd(offsetC.mon$d13C.offset))

C.stds.table$offsetC.mean <- c(offsetcorrC.mean, offsetC.mon.mean, mean(offsetC.dis$d13C.offset))
C.stds.table$offsetC.sd <- c(offsetcorrC.sd, offsetC.mon.sd, sd(offsetC.dis$d13C.offset))

C.mon.offset<-ggplot(offsetC.mon, aes(x=area44, y=d13C.offset)) +
  geom_point(shape=21, fill="orange") +
  geom_hline(yintercept=offsetC.mon.mean, colour="orange") +
  geom_hline(yintercept=offsetC.mon.mean + offsetC.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetC.mon.mean - offsetC.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetC.mon.mean + 2*offsetC.mon.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=offsetC.mon.mean - 2*offsetC.mon.sd, colour="orange", linetype=3) +
  annotate("text", y = offsetC.mon.mean +0.01, x = min(offsetC.mon$area44), label = paste0("mean: ", sprintf("%.2f", offsetC.mon.mean), " \U00B1 ", sprintf("%.2f", offsetC.mon.sd, 2), " \U2030 (1 sd)"), size = 4, hjust=0, vjust=0, parse=FALSE) +
  theme_bw()

C.mon.offset.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=offsetC.mon, aes(x=mass, y=area44), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(C.mon.offset, C.mon.offset.mass, cols=2)
```

drift corrections, using raw values
```{r drift.C, fig.width=10, fig.height=5}
driftC<-subset(stds, type=="drift.std")

drift.slopeC<-(coef(lm(driftC$d13C ~ driftC$row))[[2]])
drift.interC<-(coef(lm(driftC$d13C ~ driftC$row))[[1]])

#drift check
driftC$d13C.drift<- driftC$d13C + (C.acc - (drift.slopeC * driftC$row + drift.interC))

(driftC.mean<-mean(driftC$d13C.drift))
(driftC.sd<-sd(driftC$d13C.drift))

C.drift<-ggplot(driftC, aes(x=row, y=d13C)) +
  geom_smooth(method=lm, colour="black") +
  annotate("text", x = min(driftC$row), y = max(driftC$d13C + 0.01), label = lm_eqn(driftC$row, driftC$d13C),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=row, y=d13C.drift), fill="red", shape=21, size=2) +
  geom_hline(aes(yintercept=C.acc), size=.5) +
  geom_hline(yintercept = driftC.mean + driftC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftC.mean - driftC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftC.mean + 2*driftC.sd, colour="red", linetype=3) +
  geom_hline(yintercept = driftC.mean - 2*driftC.sd, colour="red", linetype=3) +
  annotate("text", 
    y = driftC.mean +0.01, 
    x = min(driftC$row),
    label = paste0("mean: ", sprintf("%.2f", driftC.mean), " \U00B1 ", sprintf("%.2f", driftC.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

C.drift.mass<-ggplot(subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=driftC, aes(x=mass, y=area44), shape=21, fill="red", size=3) +
  theme_bw()

multiplot(C.drift, C.drift.mass, cols=2)
```

apply drift correction to all of the data, check with monitoring standards
```{r apply.drift.corr.C, fig.width=10, fig.height=5}
data$d13C.drift <- data$d13C +  (C.acc - (drift.slopeC * data$row + drift.interC))
stds$d13C.drift <- stds$d13C +  (C.acc - (drift.slopeC * stds$row + drift.interC))

driftC.mon<-subset(stds, Identifier1==mon.std)
driftC.dis <- subset(stds, Identifier1==dis.std)

(driftC.mon.mean<-mean(driftC.mon$d13C.drift))
(driftC.mon.sd<-sd(driftC.mon$d13C.drift))

C.stds.table$driftC.mean <- c(driftC.mean, driftC.mon.mean, mean(driftC.dis$d13C.drift))
C.stds.table$driftC.sd <- c(driftC.sd, driftC.mon.sd, sd(driftC.dis$d13C.drift))

C.mon.drift<-ggplot(driftC.mon, aes(x=area44, y=d13C.drift)) +
  geom_point(shape=21, fill="red") +
  geom_hline(yintercept = driftC.mon.mean, colour="red") +
  geom_hline(yintercept = driftC.mon.mean + driftC.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftC.mon.mean - driftC.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftC.mon.mean + 2*driftC.mon.sd, colour="red", linetype=3) +
  geom_hline(yintercept = driftC.mon.mean - 2*driftC.mon.sd, colour="red", linetype=3) +
  annotate("text",
    y = driftC.mon.mean +0.01, 
    x = min(driftC.mon$area44),
    label = paste0("mean: ", sprintf("%.2f", driftC.mon.mean), " \U00B1 ", sprintf("%.2f", driftC.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")

C.mon.drift.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=driftC.mon, aes(x=mass, y=area44), shape=21, fill="red", size = 2) +
  theme_bw()

multiplot(C.mon.drift, C.mon.drift.mass, cols=2)
```

Plot linearity
```{r linearityC, fig.width=10, fig.height=5}
linC<-subset(stds, type=="lin.std") 

lin.slopeC<-(coef(lm(linC$d13C ~ linC$inv.area44))[[2]])
lin.interC<-(coef(lm(linC$d13C ~ linC$inv.area44))[[1]])

#linearity check
linC$d13C.lin<-linC$d13C + (C.acc - (lin.slopeC * linC$inv.area44 + lin.interC))

(linC.mean<-mean(linC$d13C.lin))
(linC.sd<-sd(linC$d13C.lin))

C.lin.area44<-ggplot(linC, aes(x=area44, y=d13C)) +
  geom_point(shape=21, fill="blue") +
  geom_smooth() +
  theme_bw()

C.lincorr.invarea<-ggplot(linC, aes(x=inv.area44, y=d13C)) +
  geom_smooth(method=lm) +
  annotate("text", x = min(linC$inv.area44), y = max(linC$d13C + 0.01), label = lm_eqn(linC$inv.area44, linC$d13C),  size = 4, hjust=0, vjust=0, parse=TRUE) +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=inv.area44, y=d13C.lin), fill="red", shape=22) +
  geom_hline(aes(yintercept=C.acc), size=.5) +
  geom_hline(yintercept = linC.mean + linC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = linC.mean - linC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = linC.mean + 2*linC.sd, colour="red", linetype=3) +
  geom_hline(yintercept = linC.mean - 2*linC.sd, colour="red", linetype=3) +
  annotate("text",
    y = linC.mean +0.01, 
    x = min(linC$inv.area44),
    label = paste0("mean: ", sprintf("%.2f", linC.mean), " \U00B1 ", sprintf("%.2f", linC.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

C.lin.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=linC, aes(x=mass, y=area44), shape=21, fill="blue", size = 2) +
  theme_bw()

multiplot(C.lin.area44, C.lincorr.invarea, C.lin.mass, cols=3)
```

apply linearity correction + offset correction to all of the data
```{r apply.lin.corr.C, fig.width=10, fig.height=5}

data$d13C.lin <- data$d13C +  (C.acc - (lin.slopeC * data$inv.area44 + lin.interC))
stds$d13C.lin <- stds$d13C +  (C.acc - (lin.slopeC * stds$inv.area44 + lin.interC))

linC.mon<-subset(stds, Identifier1==mon.std)
linC.dis<-subset(stds, Identifier1==dis.std)

(linC.mon.mean <- mean(linC.mon$d13C.lin))
(linC.mon.sd<-sd(linC.mon$d13C.lin))

C.stds.table$linC.mean <- c(linC.mean, linC.mon.mean, mean(linC.dis$d13C.lin))
C.stds.table$linC.sd <- c(linC.sd, linC.mon.sd, sd(linC.dis$d13C.lin))

C.mon.lin<-ggplot(linC.mon, aes(x=area44, y=d13C.lin)) +
  geom_point(shape=21, fill="blue") +
  geom_hline(yintercept = linC.mon.mean, colour="blue") +
  geom_hline(yintercept = linC.mon.mean + linC.mon.sd, colour="blue", linetype="dashed") +
  geom_hline(yintercept = linC.mon.mean - linC.mon.sd, colour="blue", linetype="dashed") +
  geom_hline(yintercept = linC.mon.mean + 2*linC.mon.sd, colour="blue", linetype=3) +
  geom_hline(yintercept = linC.mon.mean - 2*linC.mon.sd, colour="blue", linetype=3) +
  annotate("text",
    y = linC.mon.mean +0.01, 
    x = min(linC.mon$area44),
    label = paste0("mean: ", sprintf("%.2f", linC.mon.mean), " \U00B1 ", sprintf("%.2f", linC.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="blue")

C.mon.lin.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=linC.mon, aes(x=mass, y=area44), shape=21, fill="blue", size = 2) +
  theme_bw()

multiplot(C.mon.lin, C.mon.lin.mass, cols=2)
```

drift corrections on the linearity corrected values
```{r lindrift.C, fig.width=10, fig.height=5}

lindriftC <- merge(driftC, data[c("row", "d13C.lin")], by.x="row", by.y="row", all.x=TRUE, all.y=FALSE, sort=FALSE)

lindrift.slopeC<-(coef(lm(lindriftC$d13C.lin ~ lindriftC$row))[[2]])
lindrift.interC<-(coef(lm(lindriftC$d13C.lin ~ lindriftC$row))[[1]])

#drift check
lindriftC$d13C.lindrift<- lindriftC$d13C.lin + (C.acc - (lindrift.slopeC * lindriftC$row + lindrift.interC))

(lindriftC.mean<-mean(lindriftC$d13C.drift))
(lindriftC.sd<-sd(lindriftC$d13C.drift))

C.lindrift<-ggplot(lindriftC, aes(x=row, y=d13C.lin)) +
  geom_smooth(method=lm, colour="black") +
  annotate("text", x = min(lindriftC$row), y = max(lindriftC$d13C.lin + 0.01), label = lm_eqn(lindriftC$row, lindriftC$d13C.lin),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=row, y=d13C.lindrift), fill="red", shape=22, size=2) +
  geom_hline(aes(yintercept=C.acc), size=.5) +
  geom_hline(yintercept = lindriftC.mean + lindriftC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftC.mean - lindriftC.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftC.mean + 2*lindriftC.sd, colour="red", linetype=3) +
  geom_hline(yintercept = lindriftC.mean - 2*lindriftC.sd, colour="red", linetype=3) +
  annotate("text",
    y = lindriftC.mean +0.01, 
    x = min(lindriftC$row),
    label = paste0("mean: ", sprintf("%.2f", lindriftC.mean), " \U00B1 ", sprintf("%.2f", lindriftC.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

C.lindrift.mass<-ggplot(subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=lindriftC, aes(x=mass, y=area44), shape=21, fill="red", size=3) +
  theme_bw()

multiplot(C.lindrift, C.lindrift.mass, cols=2)
```

apply drift correction to all of the linearirty corrected data, check with monitoring standards
```{r apply.lindrift.corr.C, fig.width=10, fig.height=5}
data$d13C.lindrift <- data$d13C.lin +  (C.acc - (lindrift.slopeC * data$row + lindrift.interC))
stds$d13C.lindrift <- stds$d13C.lin +  (C.acc - (lindrift.slopeC * stds$row + lindrift.interC))

lindriftC.mon<-subset(stds, Identifier1==mon.std)
lindriftC.dis<-subset(stds, Identifier1==dis.std)

(lindriftC.mon.mean<-mean(lindriftC.mon$d13C.lindrift))
(lindriftC.mon.sd<-sd(lindriftC.mon$d13C.lindrift))

C.stds.table$lindriftC.mean <- c(lindriftC.mean, lindriftC.mon.mean, mean(lindriftC.dis$d13C.lindrift))
C.stds.table$lindriftC.sd <- c(lindriftC.sd, lindriftC.mon.sd, sd(lindriftC.dis$d13C.lindrift))

C.mon.drift<-ggplot(lindriftC.mon, aes(x=area44, y=d13C.lindrift)) +
  geom_point(shape=21, fill="red") +
  geom_hline(yintercept = lindriftC.mon.mean, colour="red") +
  geom_hline(yintercept = lindriftC.mon.mean + lindriftC.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftC.mon.mean - lindriftC.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftC.mon.mean + 2*lindriftC.mon.sd, colour="red", linetype=3) +
  geom_hline(yintercept = lindriftC.mon.mean - 2*lindriftC.mon.sd, colour="red", linetype=3) +
  annotate("text",
    y = lindriftC.mon.mean +0.01, 
    x = min(lindriftC.mon$area44),
    label = paste0("mean: ", sprintf("%.2f", lindriftC.mon.mean), " \U00B1 ", sprintf("%.2f", lindriftC.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")

C.mon.drift.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area44)) +
  stat_smooth(method="lm") +
  geom_point(data=lindriftC.mon, aes(x=mass, y=area44), shape=21, fill="red", size = 2) +
  theme_bw()

multiplot(C.mon.drift, C.mon.drift.mass, cols=2)
```


d13C discrimination correction - First, need to pick which correction scheme you prefer, then update this with the correct data columns
```{r apply.disc.corr.C}

# replace the character string here with the correction column you want to use
col_for_disc <- "lindrift"  # options to substitute in here are: "offset" or "drift" or  "lin" or  "lindrift"

# resulting formulas 
col_in_C.stds.table <- paste0(col_for_disc, "C.mean")
col_in_data <- paste0("d13C.", col_for_disc)
col_for_disc_mean_eq <- list(col_for_disc = lazyeval::interp(~var, var = as.name(col_in_C.stds.table)))
correction_eq <- list(d13C.disc = lazyeval::interp(~disc.slopeC * var + disc.interC, var = as.name(col_in_data)))

# safety checks
if (!col_in_C.stds.table %in% names(C.stds.table)) stop("this column does not exist in C.stds.table: ", col_in_C.stds.table, call. = FALSE)
if (!col_in_data %in% names(data)) stop("this column does not exist in data or stds table: ", col_in_data, call. = FALSE)

# regression
m <- lm(C.acc ~ col_for_disc, data = mutate_(C.stds.table, .dots = col_for_disc_mean_eq))
disc.slopeC<-(coef(m)[[2]])
disc.interC<-(coef(m)[[1]])
R2 <- summary(m)$r.squared

# apply correction
data <- mutate_(data, .dots = correction_eq)
stds <- mutate_(stds, .dots = correction_eq)

C.disc.all <- 
  ggplot(C.stds.table, aes_string(x=col_in_C.stds.table, y="C.acc")) +
  geom_smooth(method="lm", color = "blue") +
  geom_point(data=data, aes_string(x=col_in_data, y="d13C.disc"), shape=23, fill="red", size = 2) +
  geom_point(shape=21, fill="blue", size = 4) +
  geom_text(
           x = min(C.stds.table[[col_in_C.stds.table]]), 
           y = max(C.stds.table$C.acc), 
           label = str_interp("C.acc = $[.2f]{slope} ${var} + $[.2f]{intercept} (R2: $[.4f]{R2})", 
                              list(slope = disc.slopeC, intercept = disc.interC, var = col_for_disc, R2 = R2)),
           size = 4, hjust=0, vjust=0, colour="blue") +
  labs(x = col_for_disc)

C.disc.all
```

```{r add_disc_to_stds.mean.table}
discC.mon<-subset(stds, Identifier1==mon.std)
discC.dis<-subset(stds, Identifier1==dis.std)
discC.corr<-subset(stds, Identifier1==corr.std)

(discC.mon.mean<-mean(discC.mon$d13C.disc))
(discC.mon.sd<-sd(discC.mon$d13C.disc))

C.stds.table$discC.mean <- c(mean(discC.corr$d13C.disc), discC.mon.mean, mean(discC.dis$d13C.disc))
C.stds.table$discC.sd <- c(sd(discC.corr$d13C.disc), discC.mon.sd, sd(discC.dis$d13C.disc))
```

Calculate k-factor linearity to calculate weight percent C
```{r calc_percentC}
perC.stds.cull <- c(NA) #if additional standards need to be culled for the weight percent relation, put those rows in here

perC.stds <- filter(stds, !row %in% perC.stds.cull)
perC.lin <-subset(perC.stds, type=="lin.std")

perC.lin$kfactor<-C.per.acc * perC.lin$mass / perC.lin$area44

avg.kfactor.C<-mean(perC.lin$kfactor)

#check percent C calculation by applying back to correcting standards and check mean and sd
perC.lin$percent.C<-avg.kfactor.C * perC.lin$area44 / perC.lin$mass

(percentC.avg<-mean(perC.lin$percent.C))
(percentC.sd<-sd(perC.lin$percent.C))

#plot k-factor versus 1/area, to see linearity, check for outliers
perCvinv.area<-ggplot(perC.lin, aes(x=inv.area44, y=kfactor)) +
  geom_smooth(method=lm) +
  geom_point(size=3) +
  annotate("text", 
           x = min(perC.lin$inv.area44), 
           y = max(perC.lin$kfactor + 0.01), 
           label = lm_eqn(perC.lin$inv.area44, perC.lin$kfactor),  
           size = 4, hjust=0, vjust=0, parse=TRUE)

perCvarea<-ggplot(perC.lin, aes(x=area44, y=kfactor)) +
  geom_smooth() +
  geom_point(size=3)

multiplot(perCvinv.area,perCvarea, cols=2)
```

```{r apply_percentC}
data$percent.C<-avg.kfactor.C * data$area44 / data$mass
perC.stds$percent.C<-avg.kfactor.C * perC.stds$area44 / perC.stds$mass

#check effect on monitoring standard
perC.monitor.std<-subset(perC.stds, Identifier1==mon.std)

perC.monitor.std.mean<-mean(perC.monitor.std$percent.C)
perC.monitor.std.sd<-sd(perC.monitor.std$percent.C)

perC.monitor.std.mean
perC.monitor.std.sd
```

```{r add_perC_to_stds.mean.table}
perC.dis<-subset(perC.stds, Identifier1==dis.std)
perC.corr<-subset(perC.stds, Identifier1==corr.std)

C.stds.table$perC.mean <- c(mean(perC.corr$percent.C), perC.monitor.std.mean, mean(perC.dis$percent.C))
C.stds.table$perC.sd <- c(sd(perC.corr$percent.C), perC.monitor.std.sd, sd(perC.dis$percent.C))
```

```{r calc_percentC_drift}

perC.drift <- subset(perC.stds, type=="drift.std")

drift.slope.perC<-(coef(lm(perC.drift$percent.C ~ perC.drift$row))[[2]])
drift.intercept.perC<-(coef(lm(perC.drift$percent.C ~ perC.drift$row))[[1]])

#drift check
perC.drift$perC.drift<- perC.drift$percent.C + (C.per.acc - (drift.slope.perC * perC.drift$row + drift.intercept.perC))

(perC.drift.mean<-mean(perC.drift$perC.drift))
(perC.drift.sd<-sd(perC.drift$perC.drift))

drift.perC<-ggplot(perC.drift, aes(x=row, y=percent.C)) +
  geom_point(shape=21, fill="blue", size=3) +
  geom_smooth(method="lm", color="blue", se=FALSE) +
  geom_point(aes(x=row, y=perC.drift), shape=21, fill="red") +
  geom_smooth(aes(x=row, y=perC.drift), method="lm", color="red", se=FALSE) +
  annotate("text", x = 12, 
           y = C.per.acc, 
           label = lm_eqn(perC.drift$row, perC.drift$percent.C),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="blue")

drift.perC
```

```{r apply_percentC_drift}
data$perC.drift<- data$percent.C + (C.per.acc - (drift.slope.perC * data$row + drift.intercept.perC))
perC.stds$perC.drift<- perC.stds$percent.C + (C.per.acc - (drift.slope.perC * perC.stds$row + drift.intercept.perC))

#check effect on monitoring standard
perC.monitor.std.drift<-subset(perC.stds, Identifier1==mon.std)

perC.monitor.std.mean.drift<-mean(perC.monitor.std.drift$perC.drift)
perC.monitor.std.sd.drift<-sd(perC.monitor.std.drift$perC.drift)

perC.monitor.std.mean.drift
perC.monitor.std.sd.drift
```

```{r add_perCdrift_to_stds.mean.table}
perC.dis<-subset(perC.stds, Identifier1==dis.std)
perC.corr<-subset(perC.stds, Identifier1==corr.std)

C.stds.table$perC.drift.mean <- c(mean(perC.corr$perC.drift), perC.monitor.std.mean.drift, mean(perC.dis$perC.drift))
C.stds.table$perC.drift.sd <- c(sd(perC.corr$perC.drift), perC.monitor.std.sd.drift, sd(perC.dis$perC.drift))
```

## Nitrogen corrections
Determine the blank correction, before doing any of the rest of the corrections. Uses the linearity line to project to an estimated d15N value for the blank.
```{r blank.corr.N, fig.width=10, fig.height=4}
blanks<-subset(data, type=="blank")
blanks.avg.invarea28<-mean(blanks$inv.area28) #calculates average 1/area28 for all the blanks
blanks.avg.area28<-mean(blanks$area28) #calculates average area28 for all the blanks

linN<-subset(stds, type=="lin.std") 

blank.slopeN<-(coef(lm(linN$d15N ~ linN$inv.area28))[[2]]) #calculates linearity slope for blank determination, assigns name to it
blank.interN<-(coef(lm(linN$d15N ~ linN$inv.area28))[[1]]) #calculates linearity slope for blank determination, assigns name to it

A.n<-blank.slopeN * blanks.avg.invarea28 + blank.interN #calculates A.n, which is the linearity corrected d15N value for the blank

#calculating blank corrected values for the linearity dataset
linN$d15N.blcorr<-  (linN$d15N *  linN$area28 - A.n *  blanks.avg.area28) / (linN$area28- blanks.avg.area28) 

(blcorrN.mean<-mean(linN$d15N.blcorr))
(blcorrN.sd<-sd(linN$d15N.blcorr))

d15N.blank<-ggplot(linN, aes(x=area28, y=d15N.blcorr)) +
  geom_point(fill="orange", size=3, shape = 21) +
  geom_point(data=linN, aes(x=area28, y=d15N), shape=22, fill= "black", size=2) +
  geom_hline(yintercept=blcorrN.mean, colour="orange") +
  geom_hline(yintercept=blcorrN.mean + blcorrN.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=blcorrN.mean - blcorrN.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=blcorrN.mean + 2*blcorrN.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=blcorrN.mean - 2*blcorrN.sd, colour="orange", linetype=3) +
  annotate("text", y = blcorrN.mean + 0.01, x = min(linN$area28), 
    label = paste0("mean: ", sprintf("%.2f", blcorrN.mean), " \U00B1 ", sprintf("%.2f", blcorrN.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="black") +
  theme_bw() 

d15N.blank.invarea<-ggplot(linN, aes(x=inv.area28, y=d15N)) +
  geom_smooth(method=lm) +
  annotate("text", x = min(linN$inv.area28), y = max(linN$d15N + 0.01), label = lm_eqn(linN$inv.area28, linN$d15N),  size = 4, hjust=0, vjust=0, parse=TRUE) +
  geom_point(shape=21, fill="black", size=2) +
    theme_bw()

d15N.blank.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=area28, y=mass)) +
  stat_smooth(method="lm") +
  geom_point(data=linN, aes(x=area28, y=mass), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(d15N.blank, d15N.blank.invarea, d15N.blank.mass, cols=3)
```

Apply blank correction to the full dataset
```{r apply.blank.corr.N, fig.width=10, fig.height=4}
#apply blank correction to whole dataset and standards dataset
data$d15N.blcorr <- (data$d15N *  data$area28 - A.n *  blanks.avg.area28) / (data$area28 - blanks.avg.area28) 
stds$d15N.blcorr <- (stds$d15N *  stds$area28 - A.n *  blanks.avg.area28) / (stds$area28 - blanks.avg.area28)

#make monitoring standard dataset and dataset for additional standards used later for discrimination correction
blcorrN.mon <- subset(stds, Identifier1==mon.std)
blcorrN.dis <- subset(stds, Identifier1==dis.std)

#check monitoring standard response
(blcorrN.mon.mean<-mean(blcorrN.mon$d15N.blcorr))
(blcorrN.mon.sd<-sd(blcorrN.mon$d15N.blcorr))

N.stds.table$blcorrN.mean <- c(blcorrN.mean, blcorrN.mon.mean, mean(blcorrN.dis$d15N.blcorr))
N.stds.table$blcorrN.sd <- c(blcorrN.sd, blcorrN.mon.sd, sd(blcorrN.dis$d15N.blcorr))

N.mon.blcorr<-ggplot(gather(blcorrN.mon, "label", "value", d15N.blcorr, d15N), aes(x=area28, y=value, shape=label, fill=label)) +
  geom_point(size=3) +
  geom_hline(yintercept=blcorrN.mon.mean, colour="orange") +
  geom_hline(yintercept=blcorrN.mon.mean + blcorrN.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=blcorrN.mon.mean - blcorrN.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=blcorrN.mon.mean + 2*blcorrN.mon.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=blcorrN.mon.mean - 2*blcorrN.mon.sd, colour="orange", linetype=3) +
  annotate("text", y = blcorrN.mon.mean +0.01, x = min(blcorrN.mon$area28), label = paste0("mean: ", sprintf("%.2f", blcorrN.mon.mean), " \U00B1 ", sprintf("%.2f", blcorrN.mon.sd, 2), " \U2030 (1 sd)"), size = 4, hjust=0, vjust=0, parse=FALSE) +
  theme_bw() +
  scale_shape_manual(values=c(21,22))

N.mon.blcorr.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=blcorrN.mon, aes(x=mass, y=area28), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(N.mon.blcorr, N.mon.blcorr.mass, cols=2)

```

Apply basic offset correction to all of the data; does NOT include linearity or drift correction to data - culling any additional standards that should be culled (e.g. 2 sd outliers)
```{r offset.N, fig.width=10, fig.height=4}

offsetN<-subset(stds, Identifier1==corr.std)

(offsetN.mean<-mean(offsetN$d15N.blcorr))
(offsetN.sd<-sd(offsetN$d15N.blcorr))

offsetN$d15N.offset <- offsetN$d15N.blcorr +  (N.acc - offsetN.mean)

(offsetcorrN.mean<-mean(offsetN$d15N.offset))
(offsetcorrN.sd<-sd(offsetN$d15N.offset))

d15N.offset<-ggplot(offsetN, aes(x=area28, y=d15N.offset, shape=type)) +
  geom_point(fill="orange", size=3) +
  geom_hline(yintercept=offsetcorrN.mean, colour="orange") +
  geom_hline(yintercept=offsetcorrN.mean + offsetcorrN.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetcorrN.mean - offsetcorrN.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetcorrN.mean + 2*offsetcorrN.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=offsetcorrN.mean - 2*offsetcorrN.sd, colour="orange", linetype=3) +
  scale_shape_manual(values=c(21,22,23,24,25)) +
  annotate("text", y = offsetcorrN.mean + 0.01, x = min(offsetN$area28), 
    label = paste0("mean: ", sprintf("%.2f", offsetcorrN.mean), " \U00B1 ", sprintf("%.2f", offsetcorrN.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="black") +
  theme_bw() 

d15N.offset.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=offsetN, aes(x=mass, y=area28), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(d15N.offset, d15N.offset.mass, cols=2)
```

After finalizing the offset correction, apply it to the whole dataset, and check the monitoring standards
```{r apply.offset.corr.N, fig.width=10, fig.height=5}

#apply offset correction to whole dataset
data$d15N.offset <- data$d15N.blcorr +  (N.acc - offsetN.mean)
stds$d15N.offset <- stds$d15N.blcorr +  (N.acc - offsetN.mean)

#make monitoring standard dataset and dataset for additional standards used later for discrimination correction
offsetN.mon <- subset(stds, Identifier1==mon.std)
offsetN.dis <- subset(stds, Identifier1==dis.std)

#check monitoring standard response
(offsetN.mon.mean<-mean(offsetN.mon$d15N.offset))
(offsetN.mon.sd<-sd(offsetN.mon$d15N.offset))

N.stds.table$offsetN.mean <- c(offsetcorrN.mean, offsetN.mon.mean, mean(offsetN.dis$d15N.offset))
N.stds.table$offsetN.sd <- c(offsetcorrN.sd, offsetN.mon.sd, sd(offsetN.dis$d15N.offset))

N.mon.offset<-ggplot(offsetN.mon, aes(x=area28, y=d15N.offset)) +
  geom_point(shape=21, fill="orange") +
  geom_hline(yintercept=offsetN.mon.mean, colour="orange") +
  geom_hline(yintercept=offsetN.mon.mean + offsetN.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetN.mon.mean - offsetN.mon.sd, colour="orange", linetype="dashed") +
  geom_hline(yintercept=offsetN.mon.mean + 2*offsetN.mon.sd, colour="orange", linetype=3) +
  geom_hline(yintercept=offsetN.mon.mean - 2*offsetN.mon.sd, colour="orange", linetype=3) +
  annotate("text", y = offsetN.mon.mean +0.01, x = min(offsetN.mon$area28), label = paste0("mean: ", sprintf("%.2f", offsetN.mon.mean), " \U00B1 ", sprintf("%.2f", offsetN.mon.sd, 2), " \U2030 (1 sd)"), size = 4, hjust=0, vjust=0, parse=FALSE) +
  theme_bw()

N.mon.offset.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=offsetN.mon, aes(x=mass, y=area28), shape=21, fill="orange", size = 2) +
  theme_bw()

multiplot(N.mon.offset, N.mon.offset.mass, cols=2)
```

drift corrections, using raw values
```{r drift.N, fig.width=10, fig.height=5}
driftN<-subset(stds, type=="drift.std")

drift.slopeN<-(coef(lm(driftN$d15N.blcorr ~ driftN$row))[[2]])
drift.interN<-(coef(lm(driftN$d15N.blcorr ~ driftN$row))[[1]])

#drift check
driftN$d15N.drift<- driftN$d15N.blcorr + (N.acc - (drift.slopeN * driftN$row + drift.interN))

(driftN.mean<-mean(driftN$d15N.drift))
(driftN.sd<-sd(driftN$d15N.drift))

N.drift<-ggplot(driftN, aes(x=row, y=d15N.blcorr)) +
  geom_smooth(method=lm, colour="black") +
  annotate("text", x = min(driftN$row), y = max(driftN$d15N.blcorr + 0.01), label = lm_eqn(driftN$row, driftN$d15N.blcorr),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=row, y=d15N.drift), fill="red", shape=21, size=2) +
  geom_hline(aes(yintercept=N.acc), size=.5) +
  geom_hline(yintercept = driftN.mean + driftN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftN.mean - driftN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftN.mean + 2*driftN.sd, colour="red", linetype=3) +
  geom_hline(yintercept = driftN.mean - 2*driftN.sd, colour="red", linetype=3) +
  annotate("text", 
    y = driftN.mean +0.01, 
    x = min(driftN$inv.area28),
    label = paste0("mean: ", sprintf("%.2f", driftN.mean), " \U00B1 ", sprintf("%.2f", driftN.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

N.drift.mass<-ggplot(subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=driftN, aes(x=mass, y=area28), shape=21, fill="red", size=3) +
  theme_bw()

multiplot(N.drift, N.drift.mass, cols=2)
```

apply drift correction to all of the data, check with monitoring standards
```{r apply.drift.corr.N, fig.width=10, fig.height=5}
data$d15N.drift <- data$d15N.blcorr +  (N.acc - (drift.slopeN * data$row + drift.interN))
stds$d15N.drift <- stds$d15N.blcorr +  (N.acc - (drift.slopeN * stds$row + drift.interN))

driftN.mon<-subset(stds, Identifier1==mon.std)
driftN.dis <- subset(stds, Identifier1==dis.std)

(driftN.mon.mean<-mean(driftN.mon$d15N.drift))
(driftN.mon.sd<-sd(driftN.mon$d15N.drift))

N.stds.table$driftN.mean <- c(driftN.mean, driftN.mon.mean, mean(driftN.dis$d15N.drift))
N.stds.table$driftN.sd <- c(driftN.sd, driftN.mon.sd, sd(driftN.dis$d15N.drift))

N.mon.drift<-ggplot(driftN.mon, aes(x=area28, y=d15N.drift)) +
  geom_point(shape=21, fill="red") +
  geom_hline(yintercept = driftN.mon.mean, colour="red") +
  geom_hline(yintercept = driftN.mon.mean + driftN.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftN.mon.mean - driftN.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = driftN.mon.mean + 2*driftN.mon.sd, colour="red", linetype=3) +
  geom_hline(yintercept = driftN.mon.mean - 2*driftN.mon.sd, colour="red", linetype=3) +
  annotate("text",
    y = driftN.mon.mean +0.01, 
    x = min(driftN.mon$area28),
    label = paste0("mean: ", sprintf("%.2f", driftN.mon.mean), " \U00B1 ", sprintf("%.2f", driftN.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")

N.mon.drift.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=driftN.mon, aes(x=mass, y=area28), shape=21, fill="red", size = 2) +
  theme_bw()

multiplot(N.mon.drift, N.mon.drift.mass, cols=2)
```

Plot linearity
```{r linearityN, fig.width=10, fig.height=5}
linN<-subset(stds, type=="lin.std") 

lin.slopeN<-(coef(lm(linN$d15N.blcorr ~ linN$inv.area28))[[2]])
lin.interN<-(coef(lm(linN$d15N.blcorr ~ linN$inv.area28))[[1]])

#linearity check
linN$d15N.lin<-linN$d15N.blcorr + (N.acc - (lin.slopeN * linN$inv.area28 + lin.interN))

(linN.mean<-mean(linN$d15N.lin))
(linN.sd<-sd(linN$d15N.lin))

N.lin.area28<-ggplot(linN, aes(x=area28, y=d15N.blcorr)) +
  geom_point(shape=21, fill="blue") +
  geom_smooth() +
  theme_bw()

N.lincorr.invarea<-ggplot(linN, aes(x=inv.area28, y=d15N.blcorr)) +
  geom_smooth(method=lm) +
  annotate("text", x = min(linN$inv.area28), y = max(linN$d15N.blcorr + 0.01), label = lm_eqn(linN$inv.area28, linN$d15N.blcorr),  size = 4, hjust=0, vjust=0, parse=TRUE) +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=inv.area28, y=d15N.lin), fill="red", shape=22) +
  geom_hline(aes(yintercept=N.acc), size=.5) +
  geom_hline(yintercept = linN.mean + linN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = linN.mean - linN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = linN.mean + 2*linN.sd, colour="red", linetype=3) +
  geom_hline(yintercept = linN.mean - 2*linN.sd, colour="red", linetype=3) +
  annotate("text",
    y = linN.mean +0.01, 
    x = min(linN$inv.area28),
    label = paste0("mean: ", sprintf("%.2f", linN.mean), " \U00B1 ", sprintf("%.2f", linN.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

N.lin.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=linN, aes(x=mass, y=area28), shape=21, fill="blue", size = 2) +
  theme_bw()

multiplot(N.lin.area28, N.lincorr.invarea, N.lin.mass, cols=3)
```

apply linearity correction + offset correction to all of the data
```{r apply.lin.corr.N, fig.width=10, fig.height=5}

data$d15N.lin <- data$d15N.blcorr +  (N.acc - (lin.slopeN * data$inv.area28 + lin.interN))
stds$d15N.lin <- stds$d15N.blcorr +  (N.acc - (lin.slopeN * stds$inv.area28 + lin.interN))

linN.mon<-subset(stds, Identifier1==mon.std)
linN.dis<-subset(stds, Identifier1==dis.std)

(linN.mon.mean <- mean(linN.mon$d15N.lin))
(linN.mon.sd<-sd(linN.mon$d15N.lin))

N.stds.table$linN.mean <- c(linN.mean, linN.mon.mean, mean(linN.dis$d15N.lin))
N.stds.table$linN.sd <- c(linN.sd, linN.mon.sd, sd(linN.dis$d15N.lin))

N.mon.lin<-ggplot(linN.mon, aes(x=area28, y=d15N.lin)) +
  geom_point(shape=21, fill="blue") +
  geom_hline(yintercept = linN.mon.mean, colour="blue") +
  geom_hline(yintercept = linN.mon.mean + linN.mon.sd, colour="blue", linetype="dashed") +
  geom_hline(yintercept = linN.mon.mean - linN.mon.sd, colour="blue", linetype="dashed") +
  geom_hline(yintercept = linN.mon.mean + 2*linN.mon.sd, colour="blue", linetype=3) +
  geom_hline(yintercept = linN.mon.mean - 2*linN.mon.sd, colour="blue", linetype=3) +
  annotate("text",
    y = linN.mon.mean +0.01, 
    x = min(linN.mon$area28),
    label = paste0("mean: ", sprintf("%.2f", linN.mon.mean), " \U00B1 ", sprintf("%.2f", linN.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="blue")

N.mon.lin.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=linN.mon, aes(x=mass, y=area28), shape=21, fill="blue", size = 2) +
  theme_bw()

multiplot(N.mon.lin, N.mon.lin.mass, cols=2)
```

drift corrections on the linearity corrected values
```{r lindrift.N, fig.width=10, fig.height=5}

lindriftN <- merge(driftN, data[c("row", "d15N.lin")], by.x="row", by.y="row", all.x=TRUE, all.y=FALSE, sort=FALSE)

lindrift.slopeN<-(coef(lm(lindriftN$d15N.lin ~ lindriftN$row))[[2]])
lindrift.interN<-(coef(lm(lindriftN$d15N.lin ~ lindriftN$row))[[1]])

#drift check
lindriftN$d15N.lindrift<- lindriftN$d15N.lin + (N.acc - (lindrift.slopeN * lindriftN$row + lindrift.interN))

(lindriftN.mean<-mean(lindriftN$d15N.drift))
(lindriftN.sd<-sd(lindriftN$d15N.drift))

N.lindrift<-ggplot(lindriftN, aes(x=row, y=d15N.lin)) +
  geom_smooth(method=lm, colour="black") +
  annotate("text", x = min(lindriftN$row), y = max(lindriftN$d15N.lin + 0.01), label = lm_eqn(lindriftN$row, lindriftN$d15N.lin),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
  geom_point(shape=21, fill="black", size=2) +
  geom_point(aes(x=row, y=d15N.lindrift), fill="red", shape=21, size=2) +
  geom_hline(aes(yintercept=N.acc), size=.5) +
  geom_hline(yintercept = lindriftN.mean + lindriftN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftN.mean - lindriftN.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftN.mean + 2*lindriftN.sd, colour="red", linetype=3) +
  geom_hline(yintercept = lindriftN.mean - 2*lindriftN.sd, colour="red", linetype=3) +
  annotate("text",
    y = lindriftN.mean +0.01, 
    x = min(lindriftN$row),
    label = paste0("mean: ", sprintf("%.2f", lindriftN.mean), " \U00B1 ", sprintf("%.2f", lindriftN.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE) +
    theme_bw()

N.lindrift.mass<-ggplot(subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=lindriftN, aes(x=mass, y=area28), shape=21, fill="red", size=3) +
  theme_bw()

multiplot(N.lindrift, N.lindrift.mass, cols=2)
```

apply drift correction to all of the linearirty corrected data, check with monitoring standards
```{r apply.lindrift.corr.N, fig.width=10, fig.height=5}
data$d15N.lindrift <- data$d15N.lin +  (N.acc - (lindrift.slopeN * data$row + lindrift.interN))
stds$d15N.lindrift <- stds$d15N.lin +  (N.acc - (lindrift.slopeN * stds$row + lindrift.interN))

lindriftN.mon<-subset(stds, Identifier1==mon.std)
lindriftN.dis<-subset(stds, Identifier1==dis.std)

(lindriftN.mon.mean<-mean(lindriftN.mon$d15N.lindrift))
(lindriftN.mon.sd<-sd(lindriftN.mon$d15N.lindrift))

N.stds.table$lindriftN.mean <- c(lindriftN.mean, lindriftN.mon.mean, mean(lindriftN.dis$d15N.lindrift))
N.stds.table$lindriftN.sd <- c(lindriftN.sd, lindriftN.mon.sd, sd(lindriftN.dis$d15N.lindrift))

N.mon.drift<-ggplot(lindriftN.mon, aes(x=area28, y=d15N.lindrift)) +
  geom_point(shape=21, fill="red") +
  geom_hline(yintercept = lindriftN.mon.mean, colour="red") +
  geom_hline(yintercept = lindriftN.mon.mean + lindriftN.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftN.mon.mean - lindriftN.mon.sd, colour="red", linetype="dashed") +
  geom_hline(yintercept = lindriftN.mon.mean + 2*lindriftN.mon.sd, colour="red", linetype=3) +
  geom_hline(yintercept = lindriftN.mon.mean - 2*lindriftN.mon.sd, colour="red", linetype=3) +
  annotate("text",
    y = lindriftN.mon.mean +0.01, 
    x = min(lindriftN.mon$area28),
    label = paste0("mean: ", sprintf("%.2f", lindriftN.mon.mean), " \U00B1 ", sprintf("%.2f", lindriftN.mon.sd, 2), " \U2030 (1 sd)"),
    size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")

N.mon.drift.mass<-ggplot (subset(stds, type=="lin.std"), aes(x=mass, y=area28)) +
  stat_smooth(method="lm") +
  geom_point(data=lindriftN.mon, aes(x=mass, y=area28), shape=21, fill="red", size = 2) +
  theme_bw()

multiplot(N.mon.drift, N.mon.drift.mass, cols=2)
```


d15N discrimination correction - First, need to pick which correction scheme you prefer, then update this with the correct data columns
```{r apply.disc.corr.N}

# replace the character string here with the correction column you want to use
col_for_disc <- "lindrift"  # options to substitute in here are: "offset" or "drift" or  "lin" or  "lindrift"

# resulting formulas 
col_in_N.stds.table <- paste0(col_for_disc, "N.mean")
col_in_data <- paste0("d15N.", col_for_disc)
col_for_disc_mean_eq <- list(col_for_disc = lazyeval::interp(~var, var = as.name(col_in_N.stds.table)))
correction_eq <- list(d15N.disc = lazyeval::interp(~disc.slopeN * var + disc.interN, var = as.name(col_in_data)))

# safety checks
if (!col_in_N.stds.table %in% names(N.stds.table)) stop("this column does not exist in N.stds.table: ", col_in_N.stds.table, call. = FALSE)
if (!col_in_data %in% names(data)) stop("this column does not exist in data or stds table: ", col_in_data, call. = FALSE)

# regression
m <- lm(N.acc ~ col_for_disc, data = mutate_(N.stds.table, .dots = col_for_disc_mean_eq))
disc.slopeN<-(coef(m)[[2]])
disc.interN<-(coef(m)[[1]])
R2 <- summary(m)$r.squared

# apply correction
data <- mutate_(data, .dots = correction_eq)
stds <- mutate_(stds, .dots = correction_eq)

N.disc.all <- 
  ggplot(N.stds.table, aes_string(x=col_in_N.stds.table, y="N.acc")) +
  geom_smooth(method="lm", color = "blue") +
  geom_point(data=filter(data, type!="blank"), aes_string(x=col_in_data, y="d15N.disc"), shape=23, fill="red", size = 2) +
  geom_point(shape=21, fill="blue", size = 4) +
  geom_text(
           x = min(N.stds.table[[col_in_N.stds.table]]), 
           y = max(N.stds.table$N.acc), 
           label = str_interp("N.acc = $[.2f]{slope} ${var} + $[.2f]{intercept} (R2: $[.4f]{R2})", 
                              list(slope = disc.slopeN, intercept = disc.interN, var = col_for_disc, R2 = R2)),
           size = 4, hjust=0, vjust=0, colour="blue") +
  labs(x = col_for_disc)

N.disc.all
```

```{r add_disc_to_stds.mean.table.N}
discN.mon<-subset(stds, Identifier1==mon.std)
discN.dis<-subset(stds, Identifier1==dis.std)
discN.corr<-subset(stds, Identifier1==corr.std)

(discN.mon.mean<-mean(discN.mon$d15N.disc))
(discN.mon.sd<-sd(discN.mon$d15N.disc))

N.stds.table$discN.mean <- c(mean(discN.corr$d15N.disc), discN.mon.mean, mean(discN.dis$d15N.disc))
N.stds.table$discN.sd <- c(sd(discN.corr$d15N.disc), discN.mon.sd, sd(discN.dis$d15N.disc))
```

Calculate k-factor linearity to calculate weight percent N
```{r calc_percentN, fig.width=10, fig.height=5}
perN.stds.cull <- c(NA)  #if additional standards need to be culled for the weight percent relation, put those rows in here

perN.stds <- filter(stds, !row %in% perN.stds.cull)
perN.lin <-subset(perN.stds, type=="lin.std")

perN.lin$kfactor<-N.per.acc * perN.lin$mass / perN.lin$area28

avg.kfactor.N<-mean(perN.lin$kfactor)

#check percent N calculation by applying back to correcting standards and check mean and sd
perN.lin$percent.N<-avg.kfactor.N * perN.lin$area28 / perN.lin$mass

(percentN.avg<-mean(perN.lin$percent.N))
(percentN.sd<-sd(perN.lin$percent.N))

#plot k-factor versus 1/area, to see linearity, check for outliers
perNvinv.area<-ggplot(perN.lin, aes(x=inv.area28, y=kfactor)) +
  geom_smooth(method=lm) +
  geom_point(size=3) +
  annotate("text", 
           x = min(perN.lin$inv.area28), 
           y = max(perN.lin$kfactor + 0.01), 
           label = lm_eqn(perN.lin$inv.area28, perN.lin$kfactor),  
           size = 4, hjust=0, vjust=0, parse=TRUE)

perNvarea<-ggplot(perN.lin, aes(x=area28, y=kfactor)) +
  geom_smooth() +
  geom_point(size=3)

multiplot(perNvinv.area,perNvarea, cols=2)
```

```{r apply_percentN}
data$percent.N<-avg.kfactor.N * data$area28 / data$mass
perN.stds$percent.N<-avg.kfactor.N * perN.stds$area28 / perN.stds$mass

#check effect on monitoring standard
perN.monitor.std<-subset(perN.stds, Identifier1==mon.std)

perN.monitor.std.mean<-mean(perN.monitor.std$percent.N)
perN.monitor.std.sd<-sd(perN.monitor.std$percent.N)

perN.monitor.std.mean
perN.monitor.std.sd
```

```{r add_perN_to_stds.mean.table}
perN.dis<-subset(perN.stds, Identifier1==dis.std)
perN.corr<-subset(perN.stds, Identifier1==corr.std)

N.stds.table$perN.mean <- c(mean(perN.corr$percent.N), perN.monitor.std.mean, mean(perN.dis$percent.N))
N.stds.table$perN.sd <- c(sd(perN.corr$percent.N), perN.monitor.std.sd, sd(perN.dis$percent.N))
```

```{r calc_percentN_drift}

perN.drift <- subset(perN.stds, type=="drift.std")

drift.slope.perN<-(coef(lm(perN.drift$percent.N ~ perN.drift$row))[[2]])
drift.intercept.perN<-(coef(lm(perN.drift$percent.N ~ perN.drift$row))[[1]])

#drift check
perN.drift$perN.drift<- perN.drift$percent.N + (N.per.acc - (drift.slope.perN * perN.drift$row + drift.intercept.perN))

(perN.drift.mean<-mean(perN.drift$perN.drift))
(perN.drift.sd<-sd(perN.drift$perN.drift))

drift.perN<-ggplot(perN.drift, aes(x=row, y=percent.N)) +
  geom_point(shape=21, fill="blue", size=3) +
  geom_smooth(method="lm", color="blue", se=FALSE) +
  geom_point(aes(x=row, y=perN.drift), shape=21, fill="red") +
  geom_smooth(aes(x=row, y=perN.drift), method="lm", color="red", se=FALSE) +
  annotate("text", x = 12, 
           y = N.per.acc, 
           label = lm_eqn(perN.drift$row, perN.drift$percent.N),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="blue")

drift.perN
```

```{r apply_percentN_drift}
data$perN.drift<- data$percent.N + (N.per.acc - (drift.slope.perN * data$row + drift.intercept.perN))
perN.stds$perN.drift<- perN.stds$percent.N + (N.per.acc - (drift.slope.perN * perN.stds$row + drift.intercept.perN))

#check effect on monitoring standard
perN.monitor.std.drift<-subset(perN.stds, Identifier1==mon.std)

perN.monitor.std.mean.drift<-mean(perN.monitor.std.drift$perN.drift)
perN.monitor.std.sd.drift<-sd(perN.monitor.std.drift$perN.drift)

perN.monitor.std.mean.drift
perN.monitor.std.sd.drift
```

```{r add_perNdrift_to_stds.mean.table}
perN.dis<-subset(perN.stds, Identifier1==dis.std)
perN.corr<-subset(perN.stds, Identifier1==corr.std)

N.stds.table$perN.drift.mean <- c(mean(perN.corr$perN.drift), perN.monitor.std.mean.drift, mean(perN.dis$perN.drift))
N.stds.table$perN.drift.sd <- c(sd(perN.corr$perN.drift), perN.monitor.std.sd.drift, sd(perN.dis$perN.drift))
```

save data to spreadsheet
```{r save.data}
add_ws_with_data <- function(wb, sheet, data) {
  addWorksheet(wb, sheet)
  writeData(wb, sheet=sheet, data)
  return(wb)
}

wb <- createWorkbook("data") 
wb <- add_ws_with_data(wb, "offsetC", offsetC)
wb <- add_ws_with_data(wb, "driftC", driftC)
wb <- add_ws_with_data(wb, "linC", linC)
wb <- add_ws_with_data(wb, "lindriftC", lindriftC)
wb <- add_ws_with_data(wb, "C Stds means", C.stds.table)
wb <- add_ws_with_data(wb, "offsetN", offsetN)
wb <- add_ws_with_data(wb, "driftN", driftN)
wb <- add_ws_with_data(wb, "linN", linN)
wb <- add_ws_with_data(wb, "lindriftN", lindriftN)
wb <- add_ws_with_data(wb, "N Stds means", N.stds.table)
wb <- add_ws_with_data(wb, "all stds used", stds)
wb <- add_ws_with_data(wb, "culled stds", stds.culled)
wb <- add_ws_with_data(wb, "all data", data)
saveWorkbook(wb, paste0(session, "_corrected_data.xlsx"), overwrite = TRUE)
```

